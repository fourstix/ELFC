/*
 *	NMH's Simple C Compiler, 2011--2014
 *	386 target description (synthesizing generator)
 */

#include "defs.h"
#include "data.h"
#include "decl.h"
#include "cgen.h"

int entry = 0;

//void cgdata(void)	{ gen(".data"); }
//void cgtext(void)	{ gen(".text"); }
//void cgprelude(void)	{ }
//void cgpostlude(void)	{ }
//void cgpublic(char *s)	{ ngen(".globl\t%s", s, 0); }

//grw - removed gendata and gentext functions
//void cgdata(void)	{gen(";----- cgdata");}
//void cgtext(void)	{gen(";----- cgtext"); }
void cgprelude()	{
	char *pname;
	pname = procname(Basefile);
	genraw("; -------------------------------------------------------------------\n");
	genraw("; This file generated by ElfC, based on SubC\n");
	genraw("; SubC Copyright 2012-2025 by Nils Holm\n");
	genraw("; -------------------------------------------------------------------\n");
	sgenraw("#include %sinclude/%s\n", Fpath, "ops_c.inc");
	sgenraw("#include %sinclude/%s\n", Fpath, "bios.inc");
	sgenraw("#include %sinclude/%s\n", Fpath, "kernel.inc");
	sgenraw("#include %sinclude/%s\n\n", Fpath, "elfc.inc");
	sgen("           %s %s", "proc", pname);
  if (O_library) {
		entry = label();
		queue_jmp(entry);
	}
		/* moved prelude code to crt0 module */
}

void cgpostlude(void)	{ gen(";---- cgpostlude");
	char* pname;
	gen("             endp");
	//grw - make sure entry point was generated in library
	if (O_library && entry) {
		pname = procname(Basefile);
		//grw - fail if proc name is missing
		if (pname == NULL)
			error("Proc Name is Null.", NULL);

		pname++;   //grw - skip over initial C in proc name
		error("entry point function %s not found in libary file", pname);
	}
}

/* moved postlude code to crt0 module */

void cgpublic(char *s)	{ gen(";----- cgpublic");
		sgen("              %s %s", "public", s); }

//grw - cgsynth is not used
//grw - cgload2 is also not used

void cglit(int v)	{
	gen(";----- cglit");
	gen(" 				gosub s_epush16");
	ngen(" 				  %s %d", "dw", v); }
//grw - removed cglear and cglear2
//void cgclear(void)	{gen(";----- cgclear"); }
//void cgclear2(void)	{gen(";----- cgclear2"); }
//grw - added support for signed and unsigned
void cgldgb(char *s, int sgn)	{gen(";----- cgldgb");
	gen(" 				gosub s_vpush8");
	sgen(" 				  %s %s", "dw", s);
	ngen(" 				  %s %d", "db", sgn); }
void cgldgw(char *s)	{gen(";----- cgldgw");
	gen(" 				gosub s_vpush16");
	sgen(" 				  %s %s", "dw", s); }
//grw - added support for signed and unsigned
void cgldlb(int n, int sgn)	{ gen(";----- cgldlb");
	gen("          gosub s_lpush8        ; push value of local variable on ES");
	ngen("          %s  %d  ;--- offset", "dw", n);
	ngen(" 				  %s %d", "db", sgn); }
void cgldlw(int n)	{ gen(";----- cgldlw");
	gen("          gosub s_lpush16       ; push value of local variable on ES");
	ngen("          %s  %d  ;--- offset", "dw", n); }
//grw - added support for signed and unsigned
void cgldsb(int n, int sgn)	{gen(";----- cgldsb");
	gen(" 				gosub s_vpush8");
	lgen(" 				  %s %c%d", "dw", n);
	ngen(" 				  %s %d", "db", sgn); }
void cgldsw(int n)	{gen(";----- cgldsw");
	gen(" 				gosub s_vpush16");
	lgen(" 				  %s %c%d", "dw", n); }
void cgldla(int n)	{gen(";----- cgldla");
	gen("          gosub s_laddr16       ; push address of local variable on ES");
	ngen("          %s  %d  ;--- offset", "dw", n); }
void cgldsa(int n)	{gen(";----- cgldsa");
	gen(" 				gosub s_epush16");
	lgen(" 				   %s %c%d", "dw", n); }
void cgldga(char *s)	{gen(";----- cgldga");
	gen(" 				gosub s_epush16");
	sgen(" 				  %s %s", "dw", s); }
//grw - added support for signed and unsigned
void cgindb(int sgn)	{gen(";----- cgindb");
	gen(" 				gosub s_deref8");
	ngen(" 				  %s %d", "db", sgn); }
void cgindw(void)	{gen(";----- cgindw");
	gen(" 				gosub s_deref16"); }
void cgldlab(int id)	{gen(";----- cgldlab");
	gen(" 				gosub s_epush16");
  lgen(" 				  %s  %c%d", "dw", id); }

void cgpush(void)	{gen(";----- cgpush"); }
void cgpushlit(int n)	{gen(";----- cgpushlit");
		gen(" 				gosub s_epush16");
		ngen(" 				  %s %d", "dw", n); }
void cgpop2(void)	{gen(";----- cgpop2"); }
void cgswap(void)	{gen(";----- cgswap");
		gen("          gosub s_swap16				 ; swap TOS and SOS on Expression Stack\n"); }
void cgand(void)	{gen(";----- cgand");
		gen("          gosub s_and16				 ; bitwise and TOS and SOS on Expression Stack\n"); }
void cgxor(void)	{gen(";----- cgxor");
		gen("          gosub s_xor16				 ; bitwise xor TOS and SOS on Expression Stack\n"); }
void cgior(void)	{gen(";----- cgior");
    gen("          gosub s_or16	  			 ; bitwise or TOS and SOS on Expression Stack\n"); }
void cgadd(void)	{gen(";----- cgadd");
		gen("          gosub s_add16				 ; add TOS and SOS on Expression Stack\n"); }
//grw - added support for signed and unsgined
void cgmul(int sgn)	{gen(";----- cgmul");
    /* Only normalize signed operands */
		if (sgn)
      gen("          gosub s_mdsgn16			 ; prepare SOS by TOS for signed multiply\n");
		gen("          gosub s_mul16				 ; multiply SOS by TOS on Expression Stack\n"); }
void cgsub(void)	{gen(";----- cgsub");
    gen("          gosub s_sub16				 ; subtract TOS from SOS on Expression Stack\n"); }
//grw - added support for signed and unsgined
void cgdiv(int sgn)	{gen(";----- cgdiv");
    /* Only normalize signed operands */
    if (sgn)
      gen("          gosub s_mdsgn16			 ; prepare SOS by TOS for signed divide\n");
		gen("          gosub s_div16				 ; divide SOS by TOS on Expression Stack\n"); }
//grw - added support for signed and unsgined
void cgmod(int sgn)	{gen(";----- cgmod");
    /* Only normalize signed operands */
    if (sgn)
      gen("          gosub s_mdsgn16			 ; prepare SOS by TOS for signed divide\n");
    gen("          gosub s_div16				 ; divide SOS by TOS, the remainder is SOS modulo TOS\n");
		gen("          gosub s_mod16				 ; replace TOS with remainder, SOS modulo TOS \n"); }
void cgshl(void)	{gen(";----- cgshl");
		gen("          gosub s_shl16				 ; SOS shifted left by TOS on Expression Stack\n"); }
void cgshr(void)	{gen(";----- cgshr");
		gen("          gosub s_shr16				 ; SOS shifted right by TOS on Expression Stack"); }

void cgcmp(char *inst)	{ gen(";----- cgcmp"); }
void cgeq()		{gen(";----- cgeq");
		gen("          gosub s_eq16				   ; compare TOS == SOS on Expression Stack\n"); }
void cgne()		{gen(";----- cgne");
		gen("          gosub s_ne16				   ; compare TOS != SOS on Expression Stack\n"); }
void cglt()		{gen(";----- cglt");
		gen("          gosub s_lt16				   ; compare TOS < SOS on Expression Stack\n"); }
void cggt()		{gen(";----- cggt");
		gen("          gosub s_gt16				   ; compare TOS > SOS on Expression Stack\n"); }
void cgle()		{gen(";----- cgle");
		gen("          gosub s_lte16				 ; compare TOS <= SOS on Expression Stack\n"); }
void cgge()		{gen(";----- cgge");
		gen("          gosub s_gte16				 ; compare TOS >= SOS on Expression Stack\n"); }
void cgult()	{gen(";----- cgult");
		gen("          gosub s_ult16				 ; unsigned compare TOS < SOS on Expression Stack\n"); }
void cgugt()	{gen(";----- cgugt");
		gen("          gosub s_ugt16				 ; unsigned compare TOS > SOS on Expression Stack\n"); }
void cgule()	{gen(";----- cgule");
		gen("          gosub s_ule16				 ; unsigned compare TOS <= SOS on Expression Stack\n"); }
void cguge()	{gen(";----- cguge");
		gen("          gosub s_uge16				 ; unsigned compare TOS >= SOS on Expression Stack\n"); }


void cgbrcond(char *i, int n)	{ int lab;
					gen(";----- cgbrcond");
				  lab = label();
					//grw - removed cgsynthesis logic
					//grw - consume queued cmp value before lable generation
					Q_cmp = cnone;
					gen(" 				 gosub s_dpop16        ; get result from expression stack");
					gen(" 				 ghi   ra            ; get MSB from result");
					gen(" 				 str   r2            ; save in M(X)");
					gen(" 				 glo   ra            ; get LSB from result");
					gen(" 				 or                  ; D = MSB | LSB");
				  lgen("%s\t%c%d", i, lab);
					//grw - change jump to lbr instruction
				  //lgen("%s\t%c%d", "jmp", n);
					lgen("%s\t%c%d", "lbr", n);
				  genlab(lab); }

//grw - redo branch instructions to call then branch if true
void cgbreq(int n)		{gen(";----- cgbreq"); cgeq();  cgbrcond("lbnz", n); }
void cgbrne(int n)		{gen(";----- cgbrne"); cgne();  cgbrcond("lbnz", n); }
void cgbrlt(int n)		{gen(";----- cgbrlt"); cglt();  cgbrcond("lbnz", n); }
void cgbrgt(int n)		{gen(";----- cgbrgt"); cggt();  cgbrcond("lbnz", n); }
void cgbrle(int n)		{gen(";----- cgbrle"); cgle(); cgbrcond("lbnz", n); }
void cgbrge(int n)		{gen(";----- cgbrge"); cgge(); cgbrcond("lbnz", n); }
void cgbrult(int n)		{gen(";----- cgbrult"); cgult(); cgbrcond("lbnz", n); }
void cgbrugt(int n)		{gen(";----- cgbrugt"); cgugt(); cgbrcond("lbnz", n); }
void cgbrule(int n)		{gen(";----- cgbrule"); cgule(); cgbrcond("lbnz", n); }
void cgbruge(int n)		{gen(";----- cgbruge"); cguge(); cgbrcond("lbnz", n); }

void cgneg(void)	{gen(";----- cgneg");
		gen("          gosub s_neg16				 ; negate TOS on Expression Stack\n"); }
void cgnot(void)	{gen(";----- cgnot");
		gen("          gosub s_inv16				 ; bitwise invert TOS on Expression Stack\n"); }
void cglognot(void)	{gen(";----- cglognot");
		gen("          gosub s_not16				 ; logical not TOS on Expression Stack\n"); }

void cgscale(void)	{gen(";----- cgscale");
	gen(" 				gosub s_scltos2");}
void cgscale2(void)	{gen(";----- cgscale2");
	gen(" 				gosub s_sclsos2");}
void cgunscale(void)	{gen(";----- cgunscale");
	gen(" 				gosub s_unscl2");}

void cgscaleby(int v)	{
	gen(";----- cgscaleby");
 	if (v == 1)
		return;   /* no scale required */
	else if (v == 2) {
		gen(" 				gosub s_scltos2");  /* scale by shifting */
	}	else if (v == 4) {
		gen(" 				gosub s_scltos4");  /* scale by shifting twice */
	} else { /* scale by multiplication */
		gen(" 				gosub s_epush16       ; put size on stack");
		ngen(" 				  %s %d", "dw", v);
		//grw - added support for signed and unsigned
		/* gen("         gosub s_mdsgn16			  ; Removed this once unsigned supported?\n"); */
		gen("         gosub s_mul16				  ; multiply offset by size\n");
	}
}
void cgscale2by(int v){
	gen(";----- cgscale2by");
	if (v == 1)
	 return;   /* no scale required */
	else if (v == 2) {
	 gen(" 				gosub s_sclsos2");  /* scale by shifting */
 }	else if (v == 4) {
	 gen(" 				gosub s_sclsos4");  /* scale by shifting twice */
	} else { /* scale by multiplication */
	 gen("        gosub s_swap16				 ; swap TOS and SOS on Expression Stack");
	 gen(" 				gosub s_epush16        ; put size on stack");
	 ngen(" 				  %s %d", "dw", v);
	 //grw - added support for signed and unsigned
	 /* gen("        gosub s_mdsgn16			   ; Removed this once unsigned supported?\n"); */
	 gen("        gosub s_mul16				   ; multiply offset by size\n");
	 gen("        gosub s_swap16				 ; swap TOS and SOS on Expression Stack");
	}
}

void cgunscaleby(int v)	{
	gen(";----- cgunscaleby");
	if (v == 1)
	 return;   /* no unscale required */
	else if (v == 1) {
	 gen(" 				gosub s_unscl2");  /* unscale by shifting */
 }	else if (v == 4) {
	 gen(" 				gosub s_unscl4");  /* unscale by shifting */
	} else {
	 gen(" 				gosub s_epush16        ; put size on stack");
 	 ngen(" 				  %s %d", "dw", v);
	 //grw - added support for signed and unsigned
	 /* gen("        gosub s_mdsgn16			   ; Removed this once unsigned supported?\n"); */
 	 gen("        gosub s_div16				   ; divide difference by size\n");
	}
}

void cgbool(void)	{gen(";----- cgbool");
	gen(" 				  gosub s_bool16");}

//grw - increment functions
void cgldinc(void)	{gen(";----- cgldinc");
	gen(" 				 gosub s_psave        ; save pointer to pointer from stack for postfix"); }

void cginc1pi(int v)	{gen(";----- cginc1pi");
	gen(" 				 gosub s_psave        ; get pointer to pointer from stack for prefix");
	gen(" 				 gosub s_pincptr      ; increment pointer referenced by pointer");
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgdec1pi(int v)	{gen(";----- cgdec1pi");
	gen(" 				 gosub s_psave        ; get pointer to pointer from stack for prefix");
	gen(" 				 gosub s_pdecptr      ; decrement pointer referenced by pointer");
	ngen("          %s  %d  ;--- size", "dw", v); }

void cginc2pi(int v)	{gen(";----- cginc2pi");
	gen(" 				 gosub s_pincptr      ; increment pointer referenced by saved pointer");
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgdec2pi(int v)	{gen(";----- cgdec2pi");
	gen(" 				 gosub s_pdecptr      ; decrement pointer referenced by saved pointer");
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgincpl(int a, int v)	{gen(";----- cgincpl");
	gen("          gosub s_lpinc16      ; increment local pointer to 2-byte value");
	ngen("          %s  %d  ;--- offset", "dw", a);
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgdecpl(int a, int v)	{gen(";----- cgdecpl");
	gen("          gosub s_lpdec16      ; decrement local pointer to 2-byte value");
	ngen("          %s  %d  ;--- offset", "dw", a);
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgincps(int a, int v)	{gen(";----- cgincps");
	gen(" 				 gosub s_vpinc16       ; increment static pointer to 2-byte value");
	lgen(" 				  %s %c%d  ;--- address", "dw", a);
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgdecps(int a, int v)	{gen(";----- cgdecps");
	gen(" 				 gosub s_vpdec16       ; decrement static pointer to 2-byte value");
	lgen(" 				  %s %c%d  ;--- address", "dw", a);
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgincpg(char *s, int v)	{gen(";----- cgincpg");
	gen(" 				 gosub s_vpinc16       ; increment global pointer to 2-byte value");
	sgen(" 				  %s %s  ;--- address", "dw", s);
	ngen("          %s  %d  ;--- size", "dw", v); }

void cgdecpg(char *s, int v)	{gen(";----- cgdecpg");
	gen(" 				 gosub s_vpdec16       ; decrement global pointer to 2-byte value");
	sgen(" 				  %s %s  ;--- address", "dw", s);
	ngen("          %s  %d  ;--- size", "dw", v); }

void cginc1iw(void)	{gen(";----- cginc1iw");
	gen(" 				 gosub s_psave        ; save pointer from stack");
	gen("          gosub s_pinc16       ; increment variable referenced by saved pointer"); }

void cgdec1iw(void)	{gen(";----- cgdec1iw");
	gen(" 				 gosub s_psave        ; save pointer from stack");
	gen("          gosub s_pdec16       ; decrement variable referenced by saved pointer"); }

void cginc2iw(void)	{gen(";----- cginc2iw");
	gen("          gosub s_pinc16       ; increment variable referenced by saved pointer"); }

void cgdec2iw(void)	{gen(";----- cgdec2iw");
	gen("          gosub s_pdec16       ; decrement variable referenced by saved pointer"); }

void cginclw(int a)	{gen(";----- cginclw");
	gen("          gosub s_linc16       ; increment local variable");
	ngen("          %s  %d  ;--- offset", "dw", a); }

void cgdeclw(int a)	{gen(";----- cgdeclw");
	gen("          gosub s_ldec16       ; decrement local variable");
	ngen("          %s  %d  ;--- offset", "dw", a); }

void cgincsw(int a)	{gen(";----- cgincsw");
	gen(" 				 gosub s_vinc16       ; increment static variable");
	lgen(" 				  %s %c%d", "dw", a); }

void cgdecsw(int a)	{gen(";----- cgdecsw");
	gen(" 				 gosub s_vdec16       ; increment static variable");
	lgen(" 				  %s %c%d", "dw", a); }

void cgincgw(char *s)	{gen(";----- cgincgw");
	gen(" 				 gosub s_vinc16       ; increment global variable");
	sgen(" 				  %s %s", "dw", s); }

void cgdecgw(char *s)	{gen(";----- cgdecgw");
	gen(" 				 gosub s_vdec16       ; decrement global variable");
	sgen(" 				  %s %s", "dw", s); }

void cginc1ib(void)	{gen(";----- cginc1ib");
	gen(" 				 gosub s_psave        ; save pointer from stack");
	gen("          gosub s_pinc8        ; increment variable referenced by saved pointer"); }

void cgdec1ib(void)	{gen(";----- cgdec1ib");
	gen(" 				 gosub s_psave        ; save pointer from stack");
	gen("          gosub s_pdec8        ; decrement variable referenced by saved pointer"); }

void cginc2ib(void)	{gen(";----- cginc2ib");
	gen("          gosub s_pinc8        ; increment variable referenced by saved pointer"); }

void cgdec2ib(void)	{gen(";----- cgdec2ib");
	gen("          gosub s_pdec8        ; decrement variable referenced by saved pointer"); }

void cginclb(int a)	{gen(";----- cginclb");
	gen("          gosub s_linc8        ; increment local variable");
	ngen("          %s  %d  ;--- offset", "dw", a); }

void cgdeclb(int a)	{gen(";----- cgdeclb");
	gen("          gosub s_ldec8        ; decrement local variable");
	ngen("          %s  %d  ;--- offset", "dw", a); }

void cgincsb(int a)	{gen(";----- cgincsb");
	gen(" 				 gosub s_vinc8        ; increment static variable");
	lgen(" 				  %s %c%d", "dw", a); }

void cgdecsb(int a)	{gen(";----- cgdecsb");
	gen(" 				 gosub s_vdec8        ; decrement static variable");
	lgen(" 				  %s %c%d", "dw", a); }

void cgincgb(char *s)	{gen(";----- cgincgb");
	gen(" 				 gosub s_vinc8        ; increment global variable");
	sgen(" 				  %s %s", "dw", s); }

void cgdecgb(char *s)	{gen(";----- cgdecgb");
	gen(" 				 gosub s_vdec8        ; decrement global variable");
	sgen(" 				  %s %s", "dw", s); }

//grw - added short circuit flag to cgbrfalse and cgbrtrue
void cgbr(char *how, int n, int sc) {
			gen(";----- cgbr");
			if (sc)
				gen(" 				 gosub s_dget16       ; test result on expression stack for short circuit");
			else
		    gen(" 				 gosub s_dpop16       ; get result from expression stack");
			gen(" 				 ghi   ra            ; get MSB from result");
 			gen(" 				 str   r2            ; save in M(X)");
 			gen(" 				 glo   ra            ; get LSB from result");
 			gen(" 				 or                  ; D = MSB | LSB");
			lgen(" 				 %s\t%c%d           ; check for branch", how, n);
			if (sc)
			  gen(" 				 gosub s_dpop16       ; remove short circuited value from expression stack");
		 }

void cgbrtrue(int n, int sc)	{gen(";----- cgbrtrue"); cgbr("lbnz", n, sc); }
void cgbrfalse(int n, int sc)	{gen(";----- cgbrfalse"); cgbr("lbz", n, sc); }

void cgjump(int n)	{gen(";----- cgjump"); lgen(" 				  %s\t%c%d", "lbr", n); }

void cgldswtch(int n)	{gen(";----- cgldswtch"); }
void cgcalswtch(void)	{gen(";----- cgcalswtch");
			gen("          gosub s_dpop16   	   ; get switch value from expression stack"); }
void cgcase(int v, int l)
			{gen(";----- cgcase");
			ngen("%s  ra, $%04x  ;----- look for match with case value", "match", v);
			lgen("%s  %c%d", "lbz", l); }

void cgpopptr(void)	{gen(";----- cgpopptr");
	gen("          gosub s_swap16				 ; swap TOS and SOS on Expression Stack");
	gen("          gosub s_dpop16   	   ; get pointer from expression stack"); }
void cgstorib(void)	{gen(";----- cgstorib");
	gen("          gosub s_pstor8       ; store value from ES in pointer variable"); }
void cgstoriw(void)	{gen(";----- cgstoriw");
	gen("          gosub s_pstor16       ; store value from ES in pointer variable"); }
void cgstorlb(int n)	{gen(";----- cgstorlb");
	gen("          gosub s_lstor8       ; store value from ES in local variable");
	ngen("          %s  %d  ;--- offset", "dw", n); }
void cgstorlw(int n)	{gen(";----- cgstorlw");
	gen("          gosub s_lstor16      ; store value from ES in local variable");
	ngen("          %s  %d  ;--- offset", "dw", n); }
void cgstorsb(int n)	{gen(";----- cgstorsb");
	gen(" 				 gosub s_vstor8       ; store value from ES in static variable");
	lgen(" 				  %s %c%d", "dw", n); }
void cgstorsw(int n)	{gen(";----- cgstorsw");
	gen(" 				 gosub s_vstor16      ; store value from ES in static variable");
	lgen(" 				  %s %c%d", "dw", n); }
void cgstorgb(char *s)	{gen(";----- cgstorgb");
	gen(" 				 gosub s_vstor8       ; store value from ES in global variable");
	sgen(" 				  %s %s", "dw", s); }
void cgstorgw(char *s)	{gen(";----- cgstorgw");
	gen(" 				 gosub s_vstor16      ; store value from ES in global variable");
	sgen(" 				  %s %s", "dw", s); }

void cginitlw(int v, int a)	{gen(";----- cginitlw");
	gen("          gosub s_linit16         ; put value in local variable on ES");
	ngen("          %s  %d  ;--- offset", "dw", a);
	ngen("          %s  %d  ;--- init value", "dw", v); }

void cgcall(char *s)	{gen(";----- cgcall"); sgen("%s  %s", "          call", s); }
void cgcalr(int n)	{gen(";----- cgcalr");
	gen("          gosub s_dpop16 ; get function pointer from expression stack into ra");
 	lgen("          %s %c%d       ; r8 points to call address location", "load r8, ", n);
	gen("          ghi  ra   		  ; get address MSB from function pointer");
	gen("          str  r8   		  ; put function address MSB in call address");
	gen("          inc  r8   		  ; move call address pointer to LSB");
	gen("          glo  ra   		  ; get function address LSB from function pointer");
	gen("          str  r8   		  ; put function address LSB in call address");
	sgenraw("%s  %s", "          sep", "r4    ; call function address loaded from function pointer");
	genlab(n);
	ngen("%s\t 0, 0  ;----- function address from fp", "db", 0);
 }

 void cgstack(int n)	{gen(";----- cgstack");
 	gen("          gosub s_esmove				 ; move pointer for Expression Stack");
 	ngen("          %s  %d  ;--- offset", "dw", n);
 	gen("          lbdf  auto_err			 ; exit immediately when stack is exhausted by auto variables"); }

 void cgentry(void)	{
 	gen(";---- cgentry");
 	gen("          sex   r2   				 ; make sure X = SP");
 	gen("          push  rb				 		 ; save current BP (base pointer)");
 	gen("          copy  r7, rb			 	 ; set BP to current ES location"); }

 void cgexit(void)	{
 	gen(";----- cgexit");
 	gen("          sex   r2            ; make sure X = SP");
 	gen("          gosub s_stkchk        ; check for expression stack creep");
	gen("          lbdf  stk_err			 ; exit immediately when stack creep error occurs");
 	gen("          pop   rb				 		 ; restore BP (base pointer)\n");
 	gen("          rtn    			 	     ; return to caller"); }

//grw - removed cgalign
//void cgalign(void)	{ /* unused */ }

void cgdefb(int v)	{
	ngen("%s\t$%02x    ;----- cgdefb", "db", v); }

void cgdefw(int v)	{
	ngen2("%s\t$%02x, $%02x  ;----- cgdefw LSB first, MSB second", "db",	v&0x00FF, (v&0xFF00)>>8); }
void cgdefp(int v)	{
	ngen2("%s\t$%02x, $%02x  ;----- cgdefp LSB first, MSB second", "db",	v&0x00FF, (v&0xFF00)>>8); }

void cgdefl(int v)	{gen(";----- cgdefl"); lgen("%s\t%c%d", "lbr", v); }
void cgdefc(int c)	{
	if (c != '\'')
		ngen("%s\t'%c'  ;----- cgdefc", "db", c);
	else
		ngen("%s\t$%02x    ;----- cgdefc (quote char)", "db", c);
	}
void cggbss(char *s, int z)	{
	ngenraw("%s:    ds %d    ;----- cggbss\n", s, z); }

void cglbss(char *s, int z)	{
	ngenraw("%s:    ds %d    ;----- cglbss\n", s, z); }

//grw - added cgpushd and cgpopd statements
void cgpushd() {gen(";----- cgpushd");
	gen("          gosub s_dpush16   	 ; put result on expression stack"); }
void cgpopd() { gen(";----- cgpopd");
	gen("          gosub s_dpop16   		 ; get result from expression stack"); }

//grw - added cgdefs to generate string in ASM/02 format
void cgdefs(char *s, int len) {
	int i;
	int in_str = 0;
	int start = 1;
	char c;

	//grw - don't output empty string (len includes quotes, so 2 or less is empty string)
	if (len < 3)
	  return;

	genraw("  db ");

	for (i=1; i<len-1; i++) {
		c = s[i];
		if (isprint(c) && c != '\'') {
			if(!in_str) {
				in_str = 1;
				if (start)
					start = 0;
				else
				  genraw(", ");
				genraw("\'");
			} /* if !in_str */
			cgenraw("%c", c);
		} else {
			if (in_str) {
				genraw("\'");
				in_str = 0;
			}
			if (start)
				start = 0;
			else
				genraw(", ");
			cgenraw("%d", c);
		} /* if-else */
	} /* for */
	if (in_str) {
		genraw("\'");
	}
	genraw("    ;----- cgdefs\n");
}

/* create a procedure name as the file name without extension */
char *procname(char *bfile) {
	int   len;
	char *ofile;
	char *p;

	if (bfile == NULL) return NULL;

	len = strlen(bfile) + 2;
	ofile = malloc(len);

	if (ofile == NULL) return NULL;
	//grw - append "C" to the proc name for library
	if (O_library)
		sprintf(ofile, "%c%s", PREFIX, bfile);
	else
		strcpy(ofile, bfile);
	/* truncate the file name string at last period */
	p = strrchr(ofile, '.');
	if (p != NULL) {
		*p = 0;
  } /* if */
	return ofile;
}

/* return entry point for library and clear */
int cgentrypt(void) {
	int val;

	val = entry;
	entry = 0;
	return val;
}

/* Set up breakpoint handler based on program code */
void cgsetup(void) {
	genraw("\n  ;----- cgsetup\n");
	genraw("#ifdef STGROM\n");
	genraw("      load   r1, $F000  ; set up handler for STG Breakpoint\n");
	genraw("#endif\n");
}
